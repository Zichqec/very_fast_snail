OnAiTalk
{
	/*
	
	Alright bois here's what we're doing
	
	We need to create an array of 10 items, and fill it with the mix of dialogue we want
	Items are picked randomly out of it and then deleted, much like boss and SSP Angel do, to ensure a nice mix
	
	When a snail talking dialogue is picked, pick the pool based on current snailsonality
	
	When a snail poetry dialogue is picked, pick the pool based on current poetry type
	
	When a talking to snail dialogue is picked, it's just the one pool
	
	When a radio dialogue is picked, pick the dialogue based on the current station
		Should radio ads be their own thing? Maybe... we'll see if we get there
	
	I think that chains should probably also be beholden to this? although if it enters a second chain, that's a problem isn't it... we'll have to discuss.
	
	Now, there is the possible problem of IF THE POOLS GET RENAMED the current snailsonality or poetry type or whatever won't pull from the right pool
	um, that sounds like future me's problem lol. sorry future me
	
	The other thing we need to worry about is radio scanning, but tbqh, I think that can just play an extra dialogue at you when it happens...? or maybe like, the next dialogue gets queued up as a radio station change dialogue or something. yeah, cuz like, i can randomize the order here when we generate it and then just do it in order, so i could def make that happen no problem. A dialogue topic tape, if you will
	
	*/
	
	_prompt = _argv[0]
	
	LastTalk = ""
	if CHAIN.IDName != "" && _prompt == "" //TODO make sure we're not gonna have chains interrupting each other... but maybe it's fine if you prompted?
	{
		LastTalk = ChainTalk
	}
	elseif RadioScan > 0 && GETSECCOUNT >= RadioScanTime + RadioScan && RadioStation != "Off" && (_prompt == "" || _prompt == "Radio")
	{
		//TODO this needs to stop the current radio chain as well, probably? i mean it'd be nice if you switched back and it was still going, but... too messy i think
		_currentstation = REPLACE(RadioStation," ","_")
		RadioStationChange
		_nextstation = REPLACE(RadioStation," ","_")
		
		_current = EVAL("RadioStation.%(_currentstation)")
		_next = EVAL("RadioStation.%(_nextstation)")
		
		LastTalk = DialogueTransition(_current,_next)
	}
	else
	{
		if ARRAYSIZE(DialogueTape) == 0; GenerateDialogueTape
		
		_pick = ""
		if _prompt != ""
		{
			_pick = _prompt
		}
		else
		{
			_pick = DialogueTape[0]
			DialogueTape[0] = IARRAY
		}
		
		if RadioStation != "Off"
		{
			if _pick == "Radio"
			{
				if RadioStation == "Off"
				{
					LastTalk = RadioStationOff
				}
				else
				{
					_station = REPLACE(RadioStation," ","_")
					LastTalk = EVAL("RadioStation.%(_station)")
				}
			}
			elseif _pick == "Ad"
			{
				if RadioStation == "Off"; LastTalk = RadioStationOff
				elseif RadioStation == "Pirate_Radio"; LastTalk = Ads.Pirate_Radio
				else; LastTalk = Ads.General
			}
			elseif _pick == "Snail"
			{
				_alliteration = "Snailsonality"
				if IsAlliterative(CurrentSnail.Name); _alliteration = "AlliterativeSnailsonality"
				_personality = REPLACE(CurrentSnail.PersonalityType," ","_")
				LastTalk = EVAL("Talk.%(_alliteration).%(_personality)")
			}
			elseif _pick == "Poem"
			{
				_poetry = REPLACE(CurrentSnail.PoetryType," ","_")
				LastTalk = EVAL("Poetry.%(_poetry)")
			}
		}
		
		//User / fallback - this was gonna be an else, but I think I want this here in case the above functions fail because the variables are set wrong... this way you at least get SOMETHING instead of silence
		if LastTalk == ""; LastTalk = Talk.User
	}
	LastTalk
}

GenerateDialogueTape
{
	DialogueTape = IARRAY
	
	//Adjust ratios as desired... mind that 10 dialogues is 30 minutes at a 3 min interval, and there will also be radio change dialogues thrown in depending on if the scan option is on and how often the user has it set to change. note to self - don't let that be less than like 15 mins or it'll be all the dialogue lol. maybe like 1 hour as the lowest amount is good... idk, maybe 30 mins, 1 hour, 2 hours, 3 hours...
	//Also, this will bend to chains, currently... mind that
	//TODO maybe add radio ads as their own thing in the dialogue tape
	DialogueTape ,= "Radio"
	DialogueTape ,= "Radio"
	DialogueTape ,= "Radio"
	DialogueTape ,= "Ad"
	DialogueTape ,= "Ad"
	DialogueTape ,= "User"
	DialogueTape ,= "Snail"
	DialogueTape ,= "Snail"
	DialogueTape ,= "Poem"
	DialogueTape ,= "Poem"
	
	DialogueTape = ArrayShuffle(DialogueTape)
}

//I think I have a premade function for this......... somewhere. no internet, so!
ArrayShuffle
{
	_array = _argv
	_output = IARRAY
	while ARRAYSIZE(_array) > 0
	{
		_output ,= ANY(_array)
		_array[LSO] = IARRAY
	}
	_output
}

RandomTalk : nonoverlap_pool
{
	parallel RadioTalk
	parallel SnailTalk
}

RadioTalk : array
{
	_name1 = SnailNameGenerator(,"not alliteration")
	_name2 = SnailNameGenerator(,"not alliteration")
	_name3 = SnailNameGenerator(,"not alliteration")
	
	//"%(_name1) - %(_name2) - %(_name3)"
	
	"\1\b[20]Now back to our foot tapping, shell cracking, Boogie Down Music Hour! \n\n[half]\f[italic,1]Do wop~ Do be do be da do~\f[italic,default]"
	"\1\b[20]Public Safety Alert: \n\nHealthy snails start with healthy mucus. Healthy mucus starts with good hydration."
	"\1\b[20]Public Safety Alert: \n\nWatch where you step! Sticks aren't the only thing on the ground."
	"\1\b[20]Public Service Announcement: \n\nIt's a rainy day today. Do you know where your snail is?"
	"\1\b[22]Looking for snail food? \n\n\f[italic,1]Perry's Perky Pellets\f[italic,default] have perfect nutritional balance and energy for the most athletic of mollusks, all in a convenient to eat, mechanically processed cylinder!\e:chain=chain.pellet_wars"
}

chain.pellet_wars
{{CHAIN
	"\1\b[22]Are you looking for excitement in your life? A taste of something new? Tired of eating the same old cylinders day after day? \n\n\f[italic,1]Chow Cubes\f[italic,default] are for you! Shareable, stackable, and superior to traditional pellets in every way. \f[italic,1]Chow Cubes!\f[italic,default] Buy them now!"
	"\1\b[22]New research reveals that cylindrical food poses significantly lower odds of suffocation compared to trendy new %(br)'cubic' foods. \n\nThink about it: the average throat is a tube, and tubes are basically cylinders. It's a natural fit! Get your edible cylinders now! \f[italic,1]Perry's Perky Pellets!\f[italic,default]"
	"\1\b[22]This just in: a series of horrific tripping accidents are sweeping the nation. ""All it takes is a bag knocked over, and suddenly the floor is a minefield! Those cylindrical pellets are a deathtrap!"" says one very real victim. \n\nDon't take the risk. \f[italic,1]Chow Cubes!\f[italic,default] Available now!"
	"\1\b[22]What's the truth about pellets? Are some really better than others? We took to the streets to find out. \n\n""They're all terrible for snails,"" said Dr.\![dummy] Shellcracker, certified sports medicine physician. ""Snails need a variety of nutrient dense vegetables, as well as a stable source of calcium, such as eggshells. Pellets simply don't cut it, no matter the brand.""\e:chain=end"
}}CHAIN

//Make heredocs into something useful, apply linebreaks. Note that this expects two linebreaks between each poem. If we want something other than that it'll have to be handled manually
//Additional arguments are tags to be applied to the start of each poem, like alignment and balloon tags
ProcessPoems
{
	_poems = SPLIT(_argv[0],"%(C_CRLF)%(C_CRLF)%(C_CRLF)")
	
	_output = IARRAY
	foreach _poems; _poem
	{
		_temp = _poem
		if _argv[1] == 1; _temp = REPLACE(_temp,C_CRLF,"\w8\w8\n")
		else; _temp = REPLACE(_temp,C_CRLF,"\n")
		_temp = REPLACE(_temp,"::","\![]") //i dont understand why if i use a space it acts as though this whitespace is not important and discards it...
		if _argc > 2
		{
			for _i = 2; _i < _argc; _i++
			{
				_temp = _argv[_i] + _temp
			}
		}
		_output ,= _temp
	}
	
	_output
}

SkipSpaces
{
	_poems = _argv
	_output = IARRAY
	foreach _poems; _poem
	{
		_lines = SPLIT(_poem,"\n")
		_newlines = ""
		foreach _lines; _line
		{
			void RE_GREP(_line,"\s(\s+)")
			for _i = ARRAYSIZE(RE_GETSTR) - 1; _i >= 0; _i--
			{
				//_line = REPLACE(_line," " + RE_GETSTR[_i]," \![quicksection,1]" + RE_GETSTR[1] + "\![quicksection,0]",1)
				
				_str = RE_GETSTR[_i]
				_len = STRLEN(_str)
				_pos = RE_GETPOS[_i]
				
				_line = ERASE(_line,_pos,_len)
				_line = INSERT(_line,_pos," \![quicksection,1]" + SUBSTR(_str,0,_len - 1) + "\![quicksection,0]")
			}
			if _newlines != ""; _newlines += "\n"
			_newlines += _line
		}
		_output ,= _newlines
	}
	_output
}