OnTranslate
{
	_talk = reference0
	
	//This is what makes %(embedded_elements) work in script input
	if reference1 == "" && reference2 == "" //If this is from the input box
	{ //send input box : no event (ref2) , no special flag (ref1)
		_talk = EVAL('"' + REPLACE(_talk,'"','""') + '"')
		_talk = OnTranslateInternal.AutoPause(_talk)
	}
	
	_talk = REPLACE(_talk,"\1\b[1","\1%(snail)\b[1") //hmm... i hope this is enough distinction
	if SHIORI3FW.BalloonName != "Very Fast Speedway" //TODO TEST THIS i dont have the balloon on me right now
	{
		_talk = REPLACE(_talk,"\1\b[10]","\1\b[0]")
		_talk = REPLACE(_talk,"\1\b[20]","\1\b[0]")
		_talk = REPLACE(_talk,"\1\b[12]","\1\b[2]")
		_talk = REPLACE(_talk,"\1\b[22]","\1\b[2]")
	}
	
	TOSTR(_talk)
}

OnTranslateInternal.AutoPause
{
	_talk = _argv[0]
	
	if "\![no-autopause]" !_in_ _talk
	{
		/*
		_talk = REPLACE(_talk,"... ",".\w4.\w4.\w8\w8 ") //Ellipsis
		_talk = REPLACE(_talk,"...? ",".\w4.\w4.\w4?\w8\w8 ") //Question mark + ellipsis
		_talk = REPLACE(_talk,"...! ",".\w4.\w4.\w4!\w8\w8 ") //Exclamation point + ellipsis
		*/
		
		_talk = REPLACE(_talk,"\n\n ","\n\n\w8\w8") //linebreak
		_talk = REPLACE(_talk,"\n ","\n\w8\w8") //linebreak
		_talk = REPLACE(_talk,", ",",\w4 ") //Comma
		_talk = REPLACE(_talk,". ",".\w8\w8 ") //Period
		_talk = REPLACE(_talk,"? ","?\w8\w8 ") //Question mark
		_talk = REPLACE(_talk,"! ","!\w8\w8 ") //Exclamation point
		_talk = REPLACE(_talk,"; ",";\w4 ") //Semicolon
		//_talk = REPLACE(_talk,"- ","-\w8 ") //Dash - This one seems to happen a lot when I don't want it, so I am commenting it out
	}
	
	_talk
}

OnAnchorSelect
{
	if "http://" _in_ reference0 || "https://" _in_ reference0; "\j[""%(reference0)""]"
}

OnKeyPress
{
	if reference0 == "f1"; "\![open,readme]"
	elseif reference0 == "t"; OnAiTalk
	elseif reference0 == "r"; OnLastTalk
}

OnSurfaceRestore
{
	spongeoff
	--
	PositionInvisibleSnails
	--
	"\p[3]\![set,alpha,0]\s[0]"
	--
	"\0"
	--
	if RadioStation == "Off"; "\s[5]"
	elseif RadioStation == CurrentSnail.RadioPreference || CurrentSnail.Cleanliness >= 10; "\s[3]"
	else; "\s[0]"
	--
	if Racing
	{
		"\![set,scaling,%(Moonwalk)%(RaceScaling),%(RaceScaling)]"
	}
	else
	{
		"\![set,scaling,%(Moonwalk)100,100]"
	}
	--
	CleanlinessCheck
	--
	LegalityCheck
}

OnWindowStateRestore
{
	"\1\s[-1]\0\s[0]"
	--
	LegalityCheck
}

On_homeurl
{
	"https://raw.githubusercontent.com/Zichqec/very_fast_snail/main/"
}

ghostver
{
	"1.0.0"
}

GenerateSnailChoices
{
	//ty terraria for inspiring me, but i'm using a different delimiter <3
	_id = ghostver + ":" + GenerateID
	_name = SnailNameGenerator(_id)
	_trait = traits(_name)
	
	"%(_id)%(C_BYTE1)%(_name)%(C_BYTE1)%(_trait)"
}

GenerateID : all
{
	"%(RAND(10))"
	"%(RAND(10))"
	"%(RAND(10))"
	"%(RAND(10))"
	"%(RAND(10))"
	"%(RAND(10))"
	"%(RAND(10))"
	"%(RAND(10))"
	"%(RAND(10))"
	"%(RAND(10))"
	"%(RAND(10))"
	"%(RAND(10))"
	"%(RAND(10))"
	"%(RAND(10))"
	"%(RAND(10))"
	"%(RAND(10))"
}

CreateSnail
{
	CurrentSnail.ID = _argv[0]
	CurrentSnail.Name = _argv[1]
	CurrentSnail.Version = ghostver
	CurrentSnail.Trait = _argv[2]
	CurrentSnail.TotalRaces = 0
	CurrentSnail.TotalRaceTime = 0
	CurrentSnail.HighestCoolness = 0
	CurrentSnail.TotalCrashes = 0
	CurrentSnail.Loadout = IARRAY
	CurrentSnail.DateSponsored = "%(year)-%(leadingmonth)-%(leadingday):%(GETSECCOUNT)"
	CurrentSnail.Notes = IARRAY
	CurrentSnail.Training = (0,0,0,0,0,0,0,0,0,0)
	//personality type, poetry type, favorite radio station, alternate hobby
	_snailsonality = GenerateSnailsonality(CurrentSnail.Name,CurrentSnail.ID)
	CurrentSnail.PersonalityType = _snailsonality[0]
	CurrentSnail.PoetryType = _snailsonality[1]
	CurrentSnail.RadioPreference = _snailsonality[2]
	CurrentSnail.AltHobby = _snailsonality[3]
	//Xueewnr - current but my hands were on the wrong keys cuz laptop...
	CurrentSnail.Cleanliness = 0
	SaveSnail(_argv[0])
}

//Generates an array of personality traits based on the seed and name of a given snail
//arg 0: snail name (for alliteration check)
//arg 1: snail ID (seed)
//Outputs an array with the following values: personality type, poetry type, favorite radio station, alternate hobby
//More may be added in the future
GenerateSnailsonality
{
	_name = _argv[0]
	_id = _argv[1]
	if _argv[0] =="" && _argv[1] == ""
	{
		_id = ghostver + ":" + GenerateID
		_name = SnailNameGenerator(_id)
	}
	_id = _id[1,':']
	
	_firstnum = TOINT(SUBSTR(_id,0,1))
	_1st_8 = TOINT(SUBSTR(_id,0,8))
	_2nd_8 = TOINT(SUBSTR(_id,2,8))
	_3rd_8 = TOINT(SUBSTR(_id,4,8))
	_4th_8 = TOINT(SUBSTR(_id,6,8))
	_5th_8 = TOINT(SUBSTR(_id,8,8))
	_1st_10 = TOINT(SUBSTR(_id,0,10))
	_2nd_10 = TOINT(SUBSTR(_id,2,10))
	_3rd_10 = TOINT(SUBSTR(_id,4,10))
	_4th_10 = TOINT(SUBSTR(_id,6,10))
	
	_isalliterative = IsAlliterative(_name)
	_personalitytype = ""
	_poetrytype = ""
	_radiostation = ""
	_althobby = ""
	
	_personalitylist = IARRAY
	_poetrylist = GETFUNCLIST("Poetry.")
	_radiolist = GETFUNCLIST("RadioStation.")
	_althobbylist = AltHobby
	
	if _isalliterative
	{
		if SumTo10(_1st_8) >= 7 //3/10...
		{
			_personalitylist = GETFUNCLIST("Talk.AlliterativeSnailsonality.")
			_index = ASEARCH("Talk.AlliterativeSnailsonality.Basic",_personalitylist)
			_personalitylist[_index] = IARRAY
		}
		else
		{
			_personalitylist = "Talk.AlliterativeSnailsonality.Basic"
		}
		_poetrylist = "Poetry.Snoem" //TODO should... slugs all like pirate radio? so it's *usually* a tell but not always?
	}
	else
	{
		_personalitylist = GETFUNCLIST("Talk.Snailsonality.")
		
		_index = ASEARCH("Poetry.Snoem",_poetrylist)
		_poetrylist[_index] = IARRAY
		_index = ASEARCH("Poetry.Bad_Snoem",_poetrylist)
		_poetrylist[_index] = IARRAY
		
	}
	
	_personalitytype = _personalitylist[_1st_10 % ARRAYSIZE(_personalitylist)]
	_personalitytype = _personalitytype[2,'.']
	_personalitytype = REPLACE(_personalitytype,"_"," ")
	
	_poetrytype = _poetrylist[_2nd_10 % ARRAYSIZE(_poetrylist)]
	_poetrytype = _poetrytype[1,'.']
	_poetrytype = REPLACE(_poetrytype,"_"," ")
	if _personalitytype == "Bad"; _poetrytype = "Bad Snoem"
	//elseif _personalitytype == "Silent"; _poetrytype = ""
	
	_radiostation = _radiolist[_3rd_10 % ARRAYSIZE(_radiolist)]
	_radiostation = _radiostation[1,'.']
	_radiostation = REPLACE(_radiostation,"_"," ")
	
	_althobby = _althobbylist[_4th_10 % ARRAYSIZE(_althobbylist)]
	
	//"\_qName: %(_name)\nIs alliterative?: %(_isalliterative)\nID: %(_id)\nPersonality type: %(_personalitytype)\nPoetry type: %(_poetrytype)\nRadio station: %(_radiostation)\nAlt hobby: %(_althobby)\x"
	(_personalitytype,_poetrytype,_radiostation,_althobby)
}

//TODO i might want to use this over in the name generation to solve the TODO i had over there about the alliteration/not alliteration being obvious
//Sums a series of digits and outputs the result modulo 10. The purpose being to get a random looking number from a seed, and use it in a X/10 "random" calculation... same number every time but it isn't obvious to the user which number does what
SumTo10
{
	_input = TOSTR(_argv[0])
	_output = 0
	
	for _i = 0; _i < STRLEN(_input); _i++
	{
		_output += TOINT(SUBSTR(_input,_i,1))
	}
	
	_output % 10
}

GetSnailIndex
{
	ASEARCH(_argv[0],SavedSnails.ID)
}

SaveSnail
{
	_index = GetSnailIndex(_argv[0])
	if _index == -1; _index = ARRAYSIZE(SavedSnails.ID)
	
	SavedSnails.ID[_index] = CurrentSnail.ID
	SavedSnails.Name[_index] = CurrentSnail.Name
	SavedSnails.Version[_index] = CurrentSnail.Version
	SavedSnails.Trait[_index] = CurrentSnail.Trait
	SavedSnails.TotalRaces[_index] = CurrentSnail.TotalRaces
	SavedSnails.TotalRaceTime[_index] = CurrentSnail.TotalRaceTime
	SavedSnails.HighestCoolness[_index] = CurrentSnail.HighestCoolness
	SavedSnails.TotalCrashes[_index] = CurrentSnail.TotalCrashes
	
	_loadout = ""
	foreach CurrentSnail.Loadout; _item
	{
		if _loadout != ""; _loadout += "|"
		_loadout += _item
	}
	SavedSnails.Loadout[_index] = _loadout
	
	_notes = ""
	foreach CurrentSnail.Notes; _note
	{
		if _notes != ""; _notes += "|"
		_notes += _note
	}
	SavedSnails.Notes[_index] = _notes
	
	SavedSnails.DateSponsored[_index] = CurrentSnail.DateSponsored
	if CurrentSnail.Training == "" //This was added in an update so we need to account for if it doesn't exist
	{
		CurrentSnail.Training = (0,0,0,0,0,0,0,0,0,0)
	}
	
	SavedSnails.Training = TOSTR(CurrentSnail.Training)
	
	SavedSnails.PersonalityType[_index] = CurrentSnail.PersonalityType
	SavedSnails.PoetryType[_index] = CurrentSnail.PoetryType
	SavedSnails.RadioPreference[_index] = CurrentSnail.RadioPreference
	SavedSnails.AltHobby[_index] = CurrentSnail.AltHobby
	
	SavedSnails.Cleanliness[_index] = CurrentSnail.Cleanliness
	SavedSnails.LastOut[_index] = GETSECCOUNT
	
}

LoadSnail
{
	_index = GetSnailIndex(_argv[0])
	if _index == -1; _index = 0
	
	_snaildata = SPLIT(SavedSnails[_index],"|")
	
	CurrentSnail.ID = SavedSnails.ID[_index]
	CurrentSnail.Name = SavedSnails.Name[_index]
	CurrentSnail.Version = SavedSnails.Version[_index]
	CurrentSnail.Trait = SavedSnails.Trait[_index]
	CurrentSnail.TotalRaces = SavedSnails.TotalRaces[_index]
	CurrentSnail.TotalRaceTime = SavedSnails.TotalRaceTime[_index]
	CurrentSnail.HighestCoolness = SavedSnails.HighestCoolness[_index]
	CurrentSnail.TotalCrashes = SavedSnails.TotalCrashes[_index]
	
	CurrentSnail.Loadout = SPLIT(SavedSnails.Loadout[_index],"|")
	CurrentSnail.Notes = SPLIT(SavedSnails.Notes[_index],"|")
	
	CurrentSnail.DateSponsored = SavedSnails.DateSponsored[_index]
	CurrentSnail.Training = SPLIT(SavedSnails.Training,",")
	if CurrentSnail.Training == "" //This was added in an update so we need to account for if it doesn't exist
	{
		CurrentSnail.Training = (0,0,0,0,0,0,0,0,0,0)
	}
	else //if it exists make it ints
	{
		for _i = 0; _i < ARRAYSIZE(CurrentSnail.Training); _i++
		{
			CurrentSnail.Training[_i] = TOINT(CurrentSnail.Training[_i])
		}
	}
	
	_snailsonality = GenerateSnailsonality(CurrentSnail.Name,CurrentSnail.ID)
	
	CurrentSnail.PersonalityType = SavedSnails.PersonalityType[_index]
	if CurrentSnail.PersonalityType == ""; CurrentSnail.PersonalityType = _snailsonality[0]
	
	CurrentSnail.PoetryType = SavedSnails.PoetryType[_index]
	if CurrentSnail.PoetryType == ""; CurrentSnail.PoetryType = _snailsonality[1]
	
	CurrentSnail.RadioPreference = SavedSnails.RadioPreference[_index]
	if CurrentSnail.RadioPreference == ""; CurrentSnail.RadioPreference = _snailsonality[2]
	
	CurrentSnail.AltHobby = SavedSnails.AltHobby[_index]
	if CurrentSnail.AltHobby == ""; CurrentSnail.AltHobby = _snailsonality[3]
	
	CurrentSnail.Cleanliness = SavedSnails.Cleanliness[_index]
	if CurrentSnail.Cleanliness == ""; CurrentSnail.Cleanliness = 0
	if GETSECCOUNT > SavedSnails.LastOut[_index] + 600; CurrentSnail.Cleanliness = 0 //10 minute reset
	CurrentSnail.LastOut = GETSECCOUNT
}




OnNotifyDressupInfo
{
	Dressups.Current = IARRAY
	Dressups.Available = IARRAY
	Dressups.Categories = IARRAY
	
	foreach reference; _ref
	{
		//character, category, part, options, on/off, thumbnail
		if _ref[4,C_BYTE1] == "1"; Dressups.Current ,= "%(_ref[1,C_BYTE1]),%(_ref[2,C_BYTE1])"
		Dressups.Available ,= _ref
		
		if ASEARCH(_ref[1,C_BYTE1],Dressups.Categories) == -1; Dressups.Categories ,= _ref[1,C_BYTE1]
	}
}

IsOwned
{
	//category, name
	_key = "%(_argv[0]),%(_argv[1])"
	
	if ASEARCH(_key,PurchasedItems) != -1; 1
	else; 0
}

CurrentStats
{
	_array = Dressups.Current
	if _argv[0] == "loadout"; _array = CurrentSnail.Loadout
	
	
	_cost = 0
	_speed = 0
	_coolness = 0
	_explosiveness = 0
	_count = 0
	foreach _array; _dressup
	{
		foreach ItemDetails; _item
		{
			if _item[0] == _dressup[0] && _item[1] == _dressup[1]
			{
				//Category,Name,Unlocked,Price,Speed,Coolness,Explosiveness
				_speed += TOINT(_item[4])
				_coolness += TOINT(_item[5])
				_explosiveness += TOINT(_item[6])
				if !IsOwned(_dressup[0],_dressup[1])
				{
					_cost += TOINT(_item[3])
					_count++
				}
			}
		}
	}
	
	_cleanliness = ABS(CurrentSnail.Cleanliness)
	if CurrentSnail.Cleanliness >= 10
	{
		_speed += 5
		_coolness += 5
		_explosiveness -= 5
	}
	elseif CurrentSnail.Cleanliness >= 5
	{
		_speed += 2
		_coolness += 2
		_explosiveness -= 2
	}
	elseif CurrentSnail.Cleanliness < 0
	{
		_speed -= _cleanliness
		_coolness -= _cleanliness
		_explosiveness += _cleanliness
	}
	if CurrentSnail.Cleanliness == -10
	{
		_coolness += 20 //cancelling out the -10 from earlier and adding another 10
	}
	
	(_speed,_coolness,_explosiveness,_cost,_count)
}

leadingmonth : all
{
	if month <= 9; "0"
	month
}

leadingday : all
{
	if day <= 9; "0"
	day
}

TimeDisplay : all
{
	_time = TOINT(_argv[0])
	
	_days = _time / 86400
	_time %= 86400
	_hours = _time / 3600
	_time %= 3600
	_minutes = _time / 60
	_seconds = _time % 60
	
	if _days > 0; "%(_days)d "
	if _hours <= 9; "0"
	"%(_hours):"
	if _minutes <= 9; "0"
	"%(_minutes):"
	if _seconds <= 9; "0"
	"%(_seconds)"
}

MinutesSeconds : all
{
	_time = TOINT(_argv[0])
	
	_minutes = _time / 60
	_seconds = _time % 60
	
	if _minutes <= 9; "0"
	"%(_minutes):"
	if _seconds <= 9; "0"
	"%(_seconds)"
}

TimeDisplayWord
{
	_num = TOINT(_argv[0])
	if _num <= 0; {"no time"; return}
	
	//Singular form, plural form, number of seconds
	_units = ( /
	//"millenium,millenia,31536000000",/
	//"century,centuries,3153600000",/
	//"decade,decades,315360000",/
	//"year,years,31536000",/
	//"day,days,86400",/
	"hour,hours,3600",/
	"minute,minutes,60",/
	"second,seconds,1"/
	)
	
	_output = ""
	foreach _units; _unit
	{
		_duration = TOINT(_unit[2])
		_amt = _num / _duration
		_num = _num % _duration
		
		if _amt > 0
		{
			if _output != ""
			{
				if _num == 0
				{
					if "," _in_ _output; _output += ","
					_output += " and "
				}
				else; _output += ", "
			}
			
			//The second function call here handles whether the unit name should be displayed as plural or not, depending on if the amount of that unit is greater than 1
			_output += "%(_amt) %(_unit[_amt > 1])"
		}
		if _num <= 0; break
	}
	_output
}

ABS
{
	if _argv[0] < 0; _argv[0] *= -1
	_argv[0]
}

IsAlliterative
{
	_input = _argv[0]
	_chunks = REPLACE(_input,"-"," ")
	_chunks = SPLIT(_chunks," ")
	
	_letter = TOLOWER(SUBSTR(_input,0,1))
	
	foreach _chunks; _chunk
	{
		if TOLOWER(SUBSTR(_chunk,0,1)) != _letter
		{
			0
			return
		}
	}
	1
}

//snail talk rate change
snail
{
	"\![set,balloonwait,1.7]"
}

snailend
{
	"\![set,balloonwait,1]"
}

LegalityCheck : all
{
	foreach Dressups.Current; _dressup
	{
		if _dressup[0] == "Overlays"; continue
		if !IsOwned(_dressup[0],_dressup[1])
		{
			"\![bind,%(_dressup[0]),%(_dressup[1]),0]"
		}
	}
}

Moonwalk
{
	foreach Dressups.Current; _dressup
	{
		if _dressup[1] == "Moonwalk"
		{
			"-"
			return
		}
	}
}

RaceScaling
{
	20
}

L
{
	"\f[strike,1]L\f[strike,default]"
}

OnMinuteChange
{
	Lettuce++ //freebie lettuce gain
}

br
{
    if SHIORI3FW.BalloonName == "Very Fast Speedway"; "\n"
    else; " "
}

LeadingDigit : all
{
	_digit = _argv[0]
	if _digit < 10; "0"
	_digit
}

OnChoiceHover : all
{
	if reference1 == "OnEquipMenu.ToggleItem"
	{
		"\C"
		EquipMenu.ShopControls(reference2,reference3)
	}
}

OnAnchorHover : all
{
	if reference1 == "OnEquipMenu.ToggleItem"
	{
		"\C"
		EquipMenu.ShopControls(reference2,reference3)
	}
}

//ErrorLog("Some debug info","info")
ErrorLog
{
	//Create arrays if none exist
	if !ISVAR("ErrorsToPush.level"); ErrorsToPush.level = IARRAY
	if !ISVAR("ErrorsToPush.description"); ErrorsToPush.description = IARRAY
	
	_level = "warning" //It defaults to warning if it doesn't recognize what you've put in, so I will too
	if _argv[1] != ""; _level = _argv[1]
	
	ErrorsToPush.level ,= _level
	ErrorsToPush.description ,= _argv[0]
}

OnSecondChange
{
	if SHIORI3FW.DebugMode
	{
		//error logging stuff because i think tama is causing me trouble...
		//Create arrays if none exist
		if !ISVAR("ErrorsToPush.level"); ErrorsToPush.level = IARRAY
		if !ISVAR("ErrorsToPush.description"); ErrorsToPush.description = IARRAY

		if ARRAYSIZE(ErrorsToPush.level) > 0 //If there are errors
		{
			_levels = ""
			_descriptions = ""
			for _i = 0; _i < ARRAYSIZE(ErrorsToPush.level); _i++ //CHR(1) in here is the divider between errors
			{
				if _i > 0; {_levels += CHR(1); _descriptions += CHR(1)}
				_levels += ErrorsToPush.level[_i]
				_descriptions += ErrorsToPush.description[_i]
			}
			//Push the whole list of errors together
			SHIORI3FW.PushAdditionalReturn('ErrorLevel',_levels)
			SHIORI3FW.PushAdditionalReturn('ErrorDescription',_descriptions)
			
			//Clear the arrays so we don't send any more errors later
			ErrorsToPush.level = IARRAY
			ErrorsToPush.description = IARRAY
		}
	}
}

ShowInvisibleSnails : all
{
	"\p[3]\s[0]\![set,alpha,75]"
	"\p[2]\s[0]\![set,alpha,75]"
	"\p[1]\s[0]\![set,alpha,75]"
}

PositionInvisibleSnails : all
{
	"\p[2]\![set,alpha,0]\s[0]\![move,--x=0,--y=0,--base=0,--option=ignore-sticky-window]"
	"\1\![set,alpha,0]\s[0]\![move,--x=0,--y=0,--base=0,--option=ignore-sticky-window]"
}

spongebasic
{
	"\![set,property,currentghost.seriko.cursor.scope(0).mouseuplist(shell).path,spongebasic.cur]"
}

spongebetter
{
	"\![set,property,currentghost.seriko.cursor.scope(0).mouseuplist(shell).path,spongebetter.cur]"
}

spongeoff
{
	"\![set,property,currentghost.seriko.cursor.scope(0).mouseuplist(shell).path,]"
}

CleanlinessCheck : all
{
	"\![bind,Overlays,Soot Light,0]"
	"\![bind,Overlays,Soot Medium,0]"
	"\![bind,Overlays,Soot Heavy,0]"
	"\![bind,Overlays,Shine,0]"
	"\![bind,Overlays,Sparkles,0]"
	
	if CurrentSnail.Cleanliness <= -10
	{
		"\![bind,Overlays,Soot Heavy,1]"
		"\![bind,Overlays,Soot Medium,1]"
		"\![bind,Overlays,Soot Light,1]"
	}
	elseif CurrentSnail.Cleanliness <= -7
	{
		"\![bind,Overlays,Soot Heavy,1]"
		"\![bind,Overlays,Soot Light,1]"
	}
	if CurrentSnail.Cleanliness <= -5
	{
		"\![bind,Overlays,Soot Heavy,1]"
	}
	elseif CurrentSnail.Cleanliness <= -3
	{
		"\![bind,Overlays,Soot Medium,1]"
	}
	elseif CurrentSnail.Cleanliness <= -1
	{
		"\![bind,Overlays,Soot Light,1]"
	}
	
	if CurrentSnail.Cleanliness >= 5
	{
		"\![bind,Overlays,Shine,1]"
	}
	if CurrentSnail.Cleanliness >= 10
	{
		"\![bind,Overlays,Sparkles,1]"
	}
}

boing : all
{
	for _i = 100; _i >= 70; _i--
	{
		"\![set,scaling,%(Moonwalk)100,%(_i)]\_w[3]"
	}
	for _i = 70; _i < 110; _i++
	{
		"\![set,scaling,%(Moonwalk)100,%(_i)]\_w[3]"
	}
	for _i = 110; _i >= 100; _i--
	{
		"\![set,scaling,%(Moonwalk)100,%(_i)]\_w[3]"
	}
	"\![set,scaling,%(Moonwalk)100,100]"
}

bigheader : all
{
	"\f[bold,1]"
	"\f[italic,1]"
	"\f[align,center]"
	"\f[height,+2]"
	"%(_argv[0])"
	"\f[height,default]"
	"\n"
	"\f[align,left]"
	"\f[italic,default]"
	"\f[bold,default]"
	"\n"
}

TrainingCost
{
	_times_trained = _argv[0]
	
	(_times_trained * 100) + 100
}

TrainingTime
{
	_times_trained = _argv[0]
	
	(_times_trained * 10) + 10
}

newline
{
	"\n[0]"
}

RadioStationChange
{
	RadioScanTime = GETSECCOUNT
	
	_oldstation = RadioStation
	while RadioStation == _oldstation
	{
		//TODO maybe add an option for random or not here later
		if ARRAYSIZE(StationTape) == 0; StationTape = GETFUNCLIST("RadioStation.")
		
		RadioStation = ANY(StationTape)
		StationTape[LSO] = IARRAY
		
		RadioStation = REPLACE(RadioStation,"RadioStation.","")
	}
}

On_balloon_tooltip
{
	//NOTE: \n CAN BE USED HERE FOR LINEBREAK
	if reference1 == "OnRacerID" && reference4 == "OnPhotoGallery"
	{
		reference3
	}
}

BalloonIsOpen
{
	"balloon" _in_ status
}

//—————————————————————————————— Right click menu links ——————————————————————————————

//Takes an array of alternating names and urls, and formats them for use with the right click menu
FormatLinks : all
{
	for _i = 0; _i < ARRAYSIZE(_argv); _i++
	{
		_argv[_i] //Add the link/title
		//Alternate between adding %ASC(1) or %ASC(2)
		if _i % 2 == 1; "%ASC(2)"
		else; "%ASC(1)"
	}
}

On_sakura.recommendsites
{
	FormatLinks(recommendsites_sakura)
}

recommendsites_sakura : array
{
	"Link label";	"https://link.example.com/link/to/whatever/here/"
}

On_sakura.portalsites 
{
	FormatLinks(portalsites_sakura)
}

portalsites_sakura : array
{
	"Another link label";	"https://link.example.com/link/to/whatever/here/again/"
	"A third link label";	"https://link.example.com/link/to/whatever/a/third/time/you/can/add/as/many/as/you/want/"
}

//splice together two radio dialogues for a neat transition
//arg 0 is the first dialogue, arg 0 is the second
//this is kinda extremely dodgy, it's made with a lot of assumptions about how we will write our snail, it is not suitable for general use
DialogueTransition
{
	_talk1 = _argv[0]
	_talk2 = _argv[1]
	LOGGING("_talk2 at first: %(_talk2)")
	_output = ""
	
	//Get a list of all the tags
	_tags1 = SakuraScooper(_talk1)
	_tags2 = SakuraScooper(_talk2)
	
	//Remove tags and replace with C_BYTE1
	foreach _tags1; _tag
	{
		_talk1 = REPLACE(_talk1,_tag,C_BYTE1,1)
	}
	foreach _tags2; _tag
	{
		_talk2 = REPLACE(_talk2,_tag,C_BYTE1,1)
	}
	
	
	
	_startlen = STRLEN(_talk1)
	_pos1 = RAND(50) + 20
	_i = 0
	while SUBSTR(_talk1,_pos1,1) == " " || SUBSTR(_talk1,_pos1,1) == C_BYTE1 || _pos1 > _startlen
	{
		_pos1 = RAND(50) + 20
		
		_i++
		if _i > 5000; break
	}
	
	_talk1 = SUBSTR(_talk1,0,_pos1)
	foreach _tags1; _tag
	{
		_talk1 = REPLACE(_talk1,C_BYTE1,_tag,1)
	}
	_output += _talk1
	_output += "%(emdash)\n\n \f[default]\f[italic,1]%(emdash)%(gshhk)%(emdash)\f[italic,default]\n\n %(emdash)"
	
	_endlen = STRLEN(_talk2)
	_pos2 = RAND(50) + 20
	_i = 0
	while SUBSTR(_talk2,_pos2,1) == " " || SUBSTR(_talk2,_pos2,1) == C_BYTE1 || _pos2 > _endlen
	{
		_pos2 = RAND(50) + 20
		
		_i++
		if _i > 5000; break
	}
	
	_talk2first = SUBSTR(_talk2,0,_pos2)
	_talk2last = ERASE(_talk2,0,_pos2)
	
	_amt = LetterCount(_talk2first,C_BYTE1)
	_talk2tags = ""
	for _i = 0; _i < _amt; _i++
	{
		_talk2tags += C_BYTE1
	}
	
	//Put tags back into place
	
	foreach _tags2; _tag
	{
		if C_BYTE1 _in_ _talk2tags; _talk2tags = REPLACE(_talk2tags,C_BYTE1,_tag,1)
		else; _talk2last = REPLACE(_talk2last,C_BYTE1,_tag,1)
	}
	_talk2 = _talk2tags + _talk2last
	
	_output += _talk2
	
	_output
}

//Argument 0: The string to check
//Argument 1: The letter(s) to search for (case sensitive)
LetterCount
{
    _input = _argv[0]
    _let = _argv[1]
    _replaced = REPLACE(_input,_let,"")
    _num = STRLEN(_input) - STRLEN(_replaced)
    if STRLEN(_let) > 1; _num /= STRLEN(_let)
    _num
}

gshhk
{
	"GSSHK"
}

emdash
{
	"\f[name,arial]—\f[name,default]"
}


SakuraScooper
{
	_input = _argv[0]
	_scooped_tags = IARRAY

	_no_underscores = ("!","&","*","+","-","0","1","4","5","6","7","8","C","a","b","c","e","f","i","j","m","n","p","q","s","t","v","w","x","z")
	_one_underscore = ("!","+","?","V","a","b","l","m","n","q","s","v","w")
	_two_underscores = ("b","c","q","t","u","v","w")
	
	_percent = ("month","day","hour","minute","second","username","selfname","selfname2","keroname","screenwidth","screenheight","exh","et","wronghour","ms","mz","ml","mc","mh","mt","me","mp","m?","dms","lastghostname","lastobjectname","*","property")
	
	_must_have_brackets = ("\!","\&","\8","\__b","\__u","\__w","\_b","\_l","\_m","\_v","\_w","\f","\i","\j","\m","\q")
	_may_have_brackets = ("\__q","\_a","\_s","\b","\c","\n","\p","\s","\x")
	_may_have_additional = ("\b","\i","\s") //,"\w")

	_has_percent = 0
	if "%" _in_ _input; _has_percent = 1
	
	_found_all = 0
	_pos = -1
	while _found_all != 1 //Loop through to find all tags
	{
		_pos_slash = STRSTR(_input,"\",_pos + 1)
		
		if _has_percent //Don't want to be checking twice if we don't have to be...
		{
			_pos_percent = STRSTR(_input,"%",_pos + 1)
			
			if _pos_percent != -1 && _pos_percent < _pos_slash; _pos = _pos_percent
			else; _pos = _pos_slash
		}
		else; _pos = _pos_slash
		
		
		if _pos == -1; {_found_all = 1; break} //seems redundant??
		
		_underscores = 0
		_tag = ""
		_has_brackets = 0
		
		
		_checkarray = IARRAY
		
		//Determine how many underscores and what tag we have here
		if SUBSTR(_input,_pos,1) == "%"
		{
			if SUBSTR(_input,_pos,9) == "%property"; _has_brackets = 1
			_checkarray = _percent
		}
		else
		{
			_two_chars = SUBSTR(_input,_pos,2) //I was using this 3 times, so...
			if _two_chars == "\\"; continue
			elseif _two_chars == "\%"; continue
			elseif SUBSTR(_input,_pos,3) == "\__"
			{
				_underscores = 2
				_tag = "\__"
				
			}
			elseif _two_chars == "\_"
			{
				_underscores = 1
				_tag = "\_"
			}
			else
			{
				_tag = "\"
			}

			if _underscores == 2; _checkarray = _two_underscores
			elseif _underscores == 1; _checkarray = _one_underscore
			else; _checkarray = _no_underscores
			
		}
		
		//Validate tag
		_check = SUBSTR(_input,_pos + _underscores + 1,1)
		
		if ASEARCH(_check,_checkarray) == -1; continue
		
		//Check if it needs a bracket to be valid
		_tag += SUBSTR(_input,_pos + _underscores + 1,1)
		_next_char = SUBSTR(_input,_pos + _underscores + 2,1)
		_end_pos = 0
		
		if ASEARCH(_tag,_must_have_brackets) != -1
		{
			if _next_char == "["; _has_brackets = 1
			else; continue
		}
		elseif ASEARCH(_tag,_may_have_brackets) != -1
		{
			if _next_char == "["; _has_brackets = 1
			elseif ASEARCH(_tag,_may_have_additional) != -1
			{
				if ISINTSTR(_next_char); {_end_pos = _pos + 2}
				else; _end_pos = _pos +  1
			}
			else
			{
				_end_pos = _pos + 1
			}
		}
		elseif _tag == "\+" //:unamused:
		{
			if _next_char == "+"; _end_pos = _pos + 2
			else; _end_pos = _pos + 1
		}
		elseif _tag == "\w" //:deargodhelpme:
		{
			if ISINTSTR(_next_char); {_end_pos = _pos + 2}
			else; _end_pos = _pos + 1
		}
		else
		{
			_end_pos = _pos + 1
		}
		
		_startpos = _pos //This is because of nested tags... have to skip them
		//If it has brackets, grab the entire bracket section
		if _has_brackets
		{
			
			_end_found = 0
			_strpos = _pos + _underscores + 1
			_quotes_open = 0
			_escape_active = 0
			
			while !_end_found
			{
				if _strpos > STRLEN(_input); break
				
				_cur = SUBSTR(_input,_strpos,1)
				
				if _cur == '"'
				{
					if _quotes_open == 0; _quotes_open = 1
					else; _quotes_open = 0
				}
				elseif _cur == "\"
				{
					_pos = _strpos
					if _escape_active == 1; _escape_active = 0
					else; _escape_active = 2 //this will be 1 on the next go around
				}
				elseif _cur == "]"
				{
					if _escape_active == 0 && _quotes_open == 0
					{
						_end_pos = _strpos - _underscores
						_end_found = 1
						break
					}
				}
				
				if _escape_active > 0; _escape_active--
				_strpos++
			}
		}
		
		_scooped_tags ,= SUBSTR(_input,_startpos,(_end_pos + _underscores) - _startpos + 1)
	}
	_scooped_tags
}